Nice — time to **build pairs** from your shuffled list. Here’s a clean, copy-pasteable pattern that needs **no extra tables** (you can add PastPair later).

---

# Step 4 — Pairing (greedy “best partner”, avoid repeats-in-run)

## 4.1 Variables (initialize)

* **Unmatched** *(Array)* = `@{outputs('Shuffled')}`
* **Matches** *(Array)* = `[]`
* **CurrentP** *(Object)* = `{}`
* **BestCandidate** *(Object)* = `{}`
* **BestScore** *(Integer)* = `-1`
* **Leftover** *(Object)* = `{}`

> Make sure array vars are initialized with `[]` (expression), not an empty string.

## 4.2 Do until loop

**Do until** → `@{lessOrEquals(length(variables('Unmatched')), 1)}`
*(Concurrency OFF for this loop.)*

Inside the loop:

### A) Pick the first person

* **Compose – P** → `@{first(variables('Unmatched'))}`
* **Set variable – CurrentP** = outputs of **Compose – P**

### B) Candidates = everyone else

* **Compose – Candidates** → `@{skip(variables('Unmatched'), 1)}`

### C) Reset best trackers

* **Set variable – BestScore** = `-1`
* **Set variable – BestCandidate** = `{}`

### D) Score candidates

* **Apply to each – ScoreCandidates**
  **Items:** `@{outputs('Compose_-_Candidates')}`
  Inside:

  * **Compose – Score**

    ```
    @add(
      if(equals(variables('CurrentP')?['Location'], item()?['Location']), 0, 100),
      rand(0,10)
    )
    ```
  * **Condition – If better than BestScore**
    `@greater(int(outputs('Compose_-_Score')), variables('BestScore'))`

    * **If yes** branch:

      * **Set variable – BestScore** = `@{int(outputs('Compose_-_Score'))}`
      * **Set variable – BestCandidate** = `@{item()}`

> Scoring here strongly prefers **different Location** (100 pts), with a tiny random jitter to break ties.

### E) Create the pair

* **Append to array variable – Matches** (value):

  ```json
  {
    "Members": [
      @{variables('CurrentP')},
      @{variables('BestCandidate')}
    ],
    "GroupSize": 2,
    "LocationMix": "@{if(equals(variables('CurrentP')?['Location'], variables('BestCandidate')?['Location']), 'Same', 'Different')}",
    "Score": @{variables('BestScore')}
  }
  ```

### F) Remove paired people from Unmatched

* **Filter array – RemoveMatched**

  * **From:** `@{variables('Unmatched')}`
  * **Condition (advanced):**

    ```
    @and(
      not(equals(item()?['Email'], variables('CurrentP')?['Email'])),
      not(equals(item()?['Email'], variables('BestCandidate')?['Email']))
    )
    ```
* **Set variable – Unmatched** = outputs of **Filter array – RemoveMatched**

## 4.3 Handle a leftover person (optional triad)

After the Do until:

* **Condition – Has leftover?** `@equals(length(variables('Unmatched')), 1)`

  * **If yes**:

    * **Set variable – Leftover** = `@{first(variables('Unmatched'))}`

You have two easy strategies:

**A) Carry over**: note them in your run summary and force-include next time.
**B) Make a triad**: attach to the **last pair** when persisting (next step).

To do **B** later, remember: the “last match” is `last(variables('Matches'))`.

---

# Step 5 — Persist to Dataverse (minimal version: just update Participants)

> This works with only your **Participant** table.

## 5.1 Loop over Matches to update both members

* **Apply to each – PersistMatches**
  **Items:** `@{variables('Matches')}`

Inside:

* **Apply to each – Members**
  **Items:** `@{items('PersistMatches')?['Members']}`

  For each member:

  * **Update row (Dataverse) – Participant**

    * **Row ID:** `@{item()?['RowId']}`
    * **LastMatchedOn:** `@{utcNow()}`
    * **Matches Left:** `@{sub(int(item()?['MatchesLeft']), 1)}`
    * **Active:**

      ```
      @{greater(sub(int(item()?['MatchesLeft']),1), 0)}
      ```

*(Keep “Apply to each – PersistMatches” Concurrency = 1 to avoid race conditions on the same row.)*

## 5.2 If you chose **triad**

In the **Has leftover?** → **Yes** branch, after persisting the pairs:

* **Get last match object**: **Compose – LastMatch** → `@{last(variables('Matches'))}`
* **Add one more “Update row (Dataverse) – Participant”** for `variables('Leftover')` (same field updates as above).

> If you’re also writing Matches to a Match/MatchMember table, you’ll add a **third Match Member** when you create records (see below).

---

# (Optional, recommended) Step 6 — Write Match records + no-repeat history

If/when you add these Dataverse tables:

* **Match Run** (one per execution)
* **Match** (one per pair/triad)
* **Match Member** (link people to a match)
* **Past Pair** *(or query your historic Matches)*

Then, in **PersistMatches**:

1. **Add a new row – Match**
   (set *Match Run*, *Group Size*, *Score*, *Location Mix*).
2. **Add new rows – Match Member** for each member (and a 3rd if triad).
3. **Upsert Past Pair** (normalized A/B = lower/upper email) → increment count and set/update *LastMatchedOn*.
4. **Cooldown (12 months) filter** during pairing: when building **Candidates**, before scoring, exclude any candidate where a Past Pair exists with `LastMatchedOn >= addToTime(utcNow(), -12, 'Month')`.

Example cooldown check (if you preloaded PastPair into an array `PastPairs`):

```
@not(
  contains(
    join(
      select(variables('PastPairs'), 
        concat(item()?['A'],'|',item()?['B'],'|',item()?['LastMatchedOn'])
      ),
      ','
    ),
    concat(
      toLower(min(variables('CurrentP')?['Email'], item()?['Email'])),
      '|',
      toLower(max(variables('CurrentP')?['Email'], item()?['Email']))
    )
  )
)
```

*(Or do a Dataverse “Get row by alternate keys” per pair; simpler but more calls.)*

---

## That’s it

You now have:

* A **shuffled** pool → **greedy pairing** with **location weighting**
* Updates to **LastMatchedOn**, **Matches Left**, and **Active**
* Optional **triad** handling

Want me to drop in an **action-by-action list** you can mirror in your flow designer (exact action names + nesting), or move on to **notification emails** with a ready-to-send template and dynamic tokens?


concat(
  'Run timestamp: ', first(outputs('Compose'))?['RunTimestamp'], decodeUriComponent('%0D%0A'),
  'Total records to insert: ', string(first(outputs('Compose'))?['Total Records to Insert']), decodeUriComponent('%0D%0A'),
  'Errors: ', string(first(outputs('Compose'))?['Errors']), decodeUriComponent('%0D%0A'), decodeUriComponent('%0D%0A'),
  if(
    equals(length(skip(outputs('Compose'),1)), 0),
    'No errors.',
    concat(
      '------------------------------ Errorinfo ------------------------------', decodeUriComponent('%0D%0A'),
      replace(
        replace(
          replace(
            replace(
              replace(
                replace(
                  replace(
                    string(skip(outputs('Compose'),1)),
                    '[{',''
                  ),
                  '}]',''
                ),
                '},{', concat(decodeUriComponent('%0D%0A'),decodeUriComponent('%0D%0A'),
                              '------------------------------ Errorinfo ------------------------------',
                              decodeUriComponent('%0D%0A'))
              ),
              '{"ConsultationID":"','ConsultationID: '
            ),
            '","Error":"', concat(decodeUriComponent('%0D%0A'),'Error: ')
          ),
          '"}',''
        ),
        '"',''
      )
    )
  )
)




concat(
  'Run timestamp: ', first(outputs('Compose'))?['RunTimestamp'], decodeUriComponent('%0D%0A'),
  'Total records to insert: ', string(first(outputs('Compose'))?['Total Records to Insert']), decodeUriComponent('%0D%0A'),
  'Errors: ', string(first(outputs('Compose'))?['Errors']), decodeUriComponent('%0D%0A'), decodeUriComponent('%0D%0A'),
  if(
    equals(length(skip(outputs('Compose'),1)), 0),
    'No errors.',
    replace(
      replace(
        replace(
          replace(
            replace(
              replace(
                replace(
                  string(skip(outputs('Compose'),1)),
                  // 1) strip array brackets
                  '[{','{'
                ),
                '}]','}'
              ),
              // 2) mark object boundaries BEFORE removing braces
              '},{','§§SEP§§'
            ),
            // 3) label fields (add separator before each object)
            '{"ConsultationID":"',
            concat(
              '------------------------------ Errorinfo ------------------------------',
              decodeUriComponent('%0D%0A'),
              'ConsultationID: '
            )
          ),
          '","Error":"',
          concat(decodeUriComponent('%0D%0A'),'Error: ')
        ),
        // 4) now remove the trailing `"}`
        '"}',''
      ),
      // 5) clear remaining quotes
      '"',''
    ),
    // 6) turn separators into blank line + header again
    '§§SEP§§',
    concat(decodeUriComponent('%0D%0A'),decodeUriComponent('%0D%0A'),
           '------------------------------ Errorinfo ------------------------------',
           decodeUriComponent('%0D%0A'))
  )
)
